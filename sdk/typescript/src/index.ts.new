/**
 * AI Shield SDK - TypeScript SDK für AI Shield Agents API
 */

export interface AIShieldClientConfig {
  baseUrl?: string;
  apiKey?: string;
  timeout?: number; // Timeout in Millisekunden
}

export class AIShieldError extends Error {
  constructor(
    message: string,
    public status?: number,
    public body?: string
  ) {
    super(message);
    this.name = 'AIShieldError';
  }
}

export class AIShieldClient {
  private baseUrl: string;
  private apiKey?: string;
  private timeout: number;

  constructor(config: AIShieldClientConfig = {}) {
    this.baseUrl = config.baseUrl || 'http://localhost:8000';
    this.apiKey = config.apiKey;
    this.timeout = config.timeout || 30000; // Default 30 Sekunden
  }

  private async request<T>(
    method: string,
    path: string,
    body?: any,
    options?: { timeout?: number }
  ): Promise<T> {
    const headers: Record<string, string> = {};

    // Set Content-Type nur wenn Body vorhanden
    if (body) {
      headers['Content-Type'] = 'application/json';
    }

    if (this.apiKey) {
      headers['Authorization'] = `Bearer ${this.apiKey}`;
    }

    // Timeout via AbortController
    const timeoutMs = options?.timeout || this.timeout;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    try {
      const response = await fetch(`${this.baseUrl}${path}`, {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      // Handle 204 No Content
      if (response.status === 204) {
        return undefined as T;
      }

      // Parse nach Content-Type
      const contentType = response.headers.get('content-type') || '';
      let data: any;

      if (contentType.includes('application/json')) {
        try {
          data = await response.json();
        } catch (e) {
          // Fallback zu text wenn JSON parsing fehlschlägt
          const text = await response.text();
          throw new AIShieldError(
            `Invalid JSON response: ${text.substring(0, 100)}`,
            response.status,
            text
          );
        }
      } else {
        data = await response.text();
      }

      if (!response.ok) {
        const errorBody = typeof data === 'string' ? data : JSON.stringify(data);
        throw new AIShieldError(
          `API Error: ${response.status} - ${errorBody.substring(0, 200)}`,
          response.status,
          errorBody
        );
      }

      return data;
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error instanceof AIShieldError) {
        throw error;
      }
      
      if (error instanceof Error && error.name === 'AbortError') {
        throw new AIShieldError(`Request timeout after ${timeoutMs}ms`);
      }
      
      throw new AIShieldError(
        error instanceof Error ? error.message : 'Unknown error',
        undefined,
        undefined
      );
    }
  }

  // Marketplace
  async searchAgents(params?: {
    query?: string;
    category?: string;
    minRating?: number;
  }): Promise<any[]> {
    const queryParams = new URLSearchParams();
    if (params?.query) queryParams.append('query', params.query);
    if (params?.category) queryParams.append('category', params.category);
    if (params?.minRating) queryParams.append('min_rating', params.minRating.toString());

    return this.request<any[]>(
      'GET',
      `/api/v1/marketplace/agents?${queryParams.toString()}`
    );
  }

  async installAgent(agentId: string, accountId: string): Promise<any> {
    return this.request('POST', `/api/v1/marketplace/agents/${agentId}/install`, {
      account_id: accountId,
    });
  }

  // Analytics
  async trackMetric(
    metricName: string,
    value: number,
    metadata?: Record<string, any>
  ): Promise<any> {
    return this.request('POST', '/api/v1/analytics/track', {
      metric_name: metricName,
      value,
      metadata: metadata || {},
    });
  }

  async getInsights(metricName: string): Promise<any> {
    return this.request('GET', `/api/v1/analytics/insights/${metricName}`);
  }

  // Configuration
  async isFeatureEnabled(
    featureName: string,
    accountId?: string
  ): Promise<boolean> {
    const queryParams = new URLSearchParams();
    if (accountId) queryParams.append('account_id', accountId);
    
    const queryString = queryParams.toString();
    const path = `/api/v1/config/features/${featureName}/check${queryString ? `?${queryString}` : ''}`;
    
    const result = await this.request<{ enabled: boolean }>(
      'GET',
      path
    );
    return result.enabled;
  }

  // Webhooks
  async createWebhook(
    url: string,
    events: string[],
    secret?: string
  ): Promise<any> {
    return this.request('POST', '/api/v1/webhooks', {
      url,
      events,
      secret,
    });
  }

  // Costs
  async trackCost(
    accountId: string,
    costType: string,
    amount: number,
    agentName?: string
  ): Promise<any> {
    return this.request('POST', '/api/v1/costs/track', {
      account_id: accountId,
      cost_type: costType,
      amount,
      agent_name: agentName,
    });
  }

  async getCosts(accountId: string, period: string = 'monthly'): Promise<any> {
    const queryParams = new URLSearchParams();
    queryParams.append('period', period);
    return this.request('GET', `/api/v1/costs/${accountId}?${queryParams.toString()}`);
  }

  // Export
  async exportAgents(format: string = 'json'): Promise<string> {
    const queryParams = new URLSearchParams();
    queryParams.append('format', format);
    
    return this.request<string>(
      'GET',
      `/api/v1/export/agents?${queryParams.toString()}`
    );
  }
}

